// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANOMALYAPI_ANOMALY_H_
#define FLATBUFFERS_GENERATED_ANOMALYAPI_ANOMALY_H_

#include "flatbuffers/flatbuffers.h"

namespace anomaly {

struct NetInterface;
struct NetInterfaceT;

struct Config;
struct ConfigT;

struct Action;
struct ActionT;

struct ActionResponse;
struct ActionResponseT;

struct API;
struct APIT;

bool operator==(const NetInterfaceT &lhs, const NetInterfaceT &rhs);
bool operator!=(const NetInterfaceT &lhs, const NetInterfaceT &rhs);
bool operator==(const ConfigT &lhs, const ConfigT &rhs);
bool operator!=(const ConfigT &lhs, const ConfigT &rhs);
bool operator==(const ActionT &lhs, const ActionT &rhs);
bool operator!=(const ActionT &lhs, const ActionT &rhs);
bool operator==(const ActionResponseT &lhs, const ActionResponseT &rhs);
bool operator!=(const ActionResponseT &lhs, const ActionResponseT &rhs);
bool operator==(const APIT &lhs, const APIT &rhs);
bool operator!=(const APIT &lhs, const APIT &rhs);

enum ActionType {
  ActionType_Config = 0,
  ActionType_Exec = 1,
  ActionType_Spawn = 2,
  ActionType_TimedExec = 3,
  ActionType_TimedSpawn = 4,
  ActionType_Upload = 5,
  ActionType_Download = 6,
  ActionType_Gather = 7,
  ActionType_Reset = 255,
  ActionType_MIN = ActionType_Config,
  ActionType_MAX = ActionType_Reset
};

inline const ActionType (&EnumValuesActionType())[9] {
  static const ActionType values[] = {
    ActionType_Config,
    ActionType_Exec,
    ActionType_Spawn,
    ActionType_TimedExec,
    ActionType_TimedSpawn,
    ActionType_Upload,
    ActionType_Download,
    ActionType_Gather,
    ActionType_Reset
  };
  return values;
}

inline const char *EnumNameActionType(ActionType e) {
  switch (e) {
    case ActionType_Config: return "Config";
    case ActionType_Exec: return "Exec";
    case ActionType_Spawn: return "Spawn";
    case ActionType_TimedExec: return "TimedExec";
    case ActionType_TimedSpawn: return "TimedSpawn";
    case ActionType_Upload: return "Upload";
    case ActionType_Download: return "Download";
    case ActionType_Gather: return "Gather";
    case ActionType_Reset: return "Reset";
    default: return "";
  }
}

struct NetInterfaceT : public flatbuffers::NativeTable {
  typedef NetInterface TableType;
  std::string name;
  std::string macAddr;
  std::vector<std::string> ipAddrs;
  NetInterfaceT() {
  }
};

inline bool operator==(const NetInterfaceT &lhs, const NetInterfaceT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.macAddr == rhs.macAddr) &&
      (lhs.ipAddrs == rhs.ipAddrs);
}

inline bool operator!=(const NetInterfaceT &lhs, const NetInterfaceT &rhs) {
    return !(lhs == rhs);
}


struct NetInterface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetInterfaceT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MACADDR = 6,
    VT_IPADDRS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *macAddr() const {
    return GetPointer<const flatbuffers::String *>(VT_MACADDR);
  }
  flatbuffers::String *mutable_macAddr() {
    return GetPointer<flatbuffers::String *>(VT_MACADDR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *ipAddrs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IPADDRS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_ipAddrs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IPADDRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MACADDR) &&
           verifier.VerifyString(macAddr()) &&
           VerifyOffset(verifier, VT_IPADDRS) &&
           verifier.VerifyVector(ipAddrs()) &&
           verifier.VerifyVectorOfStrings(ipAddrs()) &&
           verifier.EndTable();
  }
  NetInterfaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetInterfaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NetInterface> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetInterfaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetInterfaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NetInterface::VT_NAME, name);
  }
  void add_macAddr(flatbuffers::Offset<flatbuffers::String> macAddr) {
    fbb_.AddOffset(NetInterface::VT_MACADDR, macAddr);
  }
  void add_ipAddrs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ipAddrs) {
    fbb_.AddOffset(NetInterface::VT_IPADDRS, ipAddrs);
  }
  explicit NetInterfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetInterfaceBuilder &operator=(const NetInterfaceBuilder &);
  flatbuffers::Offset<NetInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetInterface>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetInterface> CreateNetInterface(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> macAddr = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ipAddrs = 0) {
  NetInterfaceBuilder builder_(_fbb);
  builder_.add_ipAddrs(ipAddrs);
  builder_.add_macAddr(macAddr);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<NetInterface> CreateNetInterfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *macAddr = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *ipAddrs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto macAddr__ = macAddr ? _fbb.CreateString(macAddr) : 0;
  auto ipAddrs__ = ipAddrs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*ipAddrs) : 0;
  return anomaly::CreateNetInterface(
      _fbb,
      name__,
      macAddr__,
      ipAddrs__);
}

flatbuffers::Offset<NetInterface> CreateNetInterface(flatbuffers::FlatBufferBuilder &_fbb, const NetInterfaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConfigT : public flatbuffers::NativeTable {
  typedef Config TableType;
  int32_t interval;
  int32_t intervalDelta;
  std::string agentVersion;
  std::vector<std::string> servers;
  ConfigT()
      : interval(0),
        intervalDelta(0) {
  }
};

inline bool operator==(const ConfigT &lhs, const ConfigT &rhs) {
  return
      (lhs.interval == rhs.interval) &&
      (lhs.intervalDelta == rhs.intervalDelta) &&
      (lhs.agentVersion == rhs.agentVersion) &&
      (lhs.servers == rhs.servers);
}

inline bool operator!=(const ConfigT &lhs, const ConfigT &rhs) {
    return !(lhs == rhs);
}


struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERVAL = 4,
    VT_INTERVALDELTA = 6,
    VT_AGENTVERSION = 8,
    VT_SERVERS = 10
  };
  int32_t interval() const {
    return GetField<int32_t>(VT_INTERVAL, 0);
  }
  bool mutate_interval(int32_t _interval) {
    return SetField<int32_t>(VT_INTERVAL, _interval, 0);
  }
  int32_t intervalDelta() const {
    return GetField<int32_t>(VT_INTERVALDELTA, 0);
  }
  bool mutate_intervalDelta(int32_t _intervalDelta) {
    return SetField<int32_t>(VT_INTERVALDELTA, _intervalDelta, 0);
  }
  const flatbuffers::String *agentVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_AGENTVERSION);
  }
  flatbuffers::String *mutable_agentVersion() {
    return GetPointer<flatbuffers::String *>(VT_AGENTVERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *servers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SERVERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_servers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SERVERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INTERVAL) &&
           VerifyField<int32_t>(verifier, VT_INTERVALDELTA) &&
           VerifyOffset(verifier, VT_AGENTVERSION) &&
           verifier.VerifyString(agentVersion()) &&
           VerifyOffset(verifier, VT_SERVERS) &&
           verifier.VerifyVector(servers()) &&
           verifier.VerifyVectorOfStrings(servers()) &&
           verifier.EndTable();
  }
  ConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Config> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_interval(int32_t interval) {
    fbb_.AddElement<int32_t>(Config::VT_INTERVAL, interval, 0);
  }
  void add_intervalDelta(int32_t intervalDelta) {
    fbb_.AddElement<int32_t>(Config::VT_INTERVALDELTA, intervalDelta, 0);
  }
  void add_agentVersion(flatbuffers::Offset<flatbuffers::String> agentVersion) {
    fbb_.AddOffset(Config::VT_AGENTVERSION, agentVersion);
  }
  void add_servers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> servers) {
    fbb_.AddOffset(Config::VT_SERVERS, servers);
  }
  explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigBuilder &operator=(const ConfigBuilder &);
  flatbuffers::Offset<Config> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Config>(end);
    return o;
  }
};

inline flatbuffers::Offset<Config> CreateConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t interval = 0,
    int32_t intervalDelta = 0,
    flatbuffers::Offset<flatbuffers::String> agentVersion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> servers = 0) {
  ConfigBuilder builder_(_fbb);
  builder_.add_servers(servers);
  builder_.add_agentVersion(agentVersion);
  builder_.add_intervalDelta(intervalDelta);
  builder_.add_interval(interval);
  return builder_.Finish();
}

inline flatbuffers::Offset<Config> CreateConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t interval = 0,
    int32_t intervalDelta = 0,
    const char *agentVersion = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *servers = nullptr) {
  auto agentVersion__ = agentVersion ? _fbb.CreateString(agentVersion) : 0;
  auto servers__ = servers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*servers) : 0;
  return anomaly::CreateConfig(
      _fbb,
      interval,
      intervalDelta,
      agentVersion__,
      servers__);
}

flatbuffers::Offset<Config> CreateConfig(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionT : public flatbuffers::NativeTable {
  typedef Action TableType;
  std::string actionId;
  ActionType actionType;
  std::unique_ptr<ConfigT> config;
  std::string command;
  std::vector<std::string> args;
  float activateTime;
  float currentTime;
  std::string remotePath;
  std::vector<int8_t> file;
  ActionT()
      : actionType(ActionType_Config),
        activateTime(0.0f),
        currentTime(0.0f) {
  }
};

inline bool operator==(const ActionT &lhs, const ActionT &rhs) {
  return
      (lhs.actionId == rhs.actionId) &&
      (lhs.actionType == rhs.actionType) &&
      (lhs.config == rhs.config) &&
      (lhs.command == rhs.command) &&
      (lhs.args == rhs.args) &&
      (lhs.activateTime == rhs.activateTime) &&
      (lhs.currentTime == rhs.currentTime) &&
      (lhs.remotePath == rhs.remotePath) &&
      (lhs.file == rhs.file);
}

inline bool operator!=(const ActionT &lhs, const ActionT &rhs) {
    return !(lhs == rhs);
}


struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIONID = 4,
    VT_ACTIONTYPE = 6,
    VT_CONFIG = 8,
    VT_COMMAND = 10,
    VT_ARGS = 12,
    VT_ACTIVATETIME = 14,
    VT_CURRENTTIME = 16,
    VT_REMOTEPATH = 18,
    VT_FILE = 20
  };
  const flatbuffers::String *actionId() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTIONID);
  }
  flatbuffers::String *mutable_actionId() {
    return GetPointer<flatbuffers::String *>(VT_ACTIONID);
  }
  ActionType actionType() const {
    return static_cast<ActionType>(GetField<uint8_t>(VT_ACTIONTYPE, 0));
  }
  bool mutate_actionType(ActionType _actionType) {
    return SetField<uint8_t>(VT_ACTIONTYPE, static_cast<uint8_t>(_actionType), 0);
  }
  const Config *config() const {
    return GetPointer<const Config *>(VT_CONFIG);
  }
  Config *mutable_config() {
    return GetPointer<Config *>(VT_CONFIG);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  flatbuffers::String *mutable_command() {
    return GetPointer<flatbuffers::String *>(VT_COMMAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_args() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGS);
  }
  float activateTime() const {
    return GetField<float>(VT_ACTIVATETIME, 0.0f);
  }
  bool mutate_activateTime(float _activateTime) {
    return SetField<float>(VT_ACTIVATETIME, _activateTime, 0.0f);
  }
  float currentTime() const {
    return GetField<float>(VT_CURRENTTIME, 0.0f);
  }
  bool mutate_currentTime(float _currentTime) {
    return SetField<float>(VT_CURRENTTIME, _currentTime, 0.0f);
  }
  const flatbuffers::String *remotePath() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTEPATH);
  }
  flatbuffers::String *mutable_remotePath() {
    return GetPointer<flatbuffers::String *>(VT_REMOTEPATH);
  }
  const flatbuffers::Vector<int8_t> *file() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_FILE);
  }
  flatbuffers::Vector<int8_t> *mutable_file() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIONID) &&
           verifier.VerifyString(actionId()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIONTYPE) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfStrings(args()) &&
           VerifyField<float>(verifier, VT_ACTIVATETIME) &&
           VerifyField<float>(verifier, VT_CURRENTTIME) &&
           VerifyOffset(verifier, VT_REMOTEPATH) &&
           verifier.VerifyString(remotePath()) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyVector(file()) &&
           verifier.EndTable();
  }
  ActionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Action> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actionId(flatbuffers::Offset<flatbuffers::String> actionId) {
    fbb_.AddOffset(Action::VT_ACTIONID, actionId);
  }
  void add_actionType(ActionType actionType) {
    fbb_.AddElement<uint8_t>(Action::VT_ACTIONTYPE, static_cast<uint8_t>(actionType), 0);
  }
  void add_config(flatbuffers::Offset<Config> config) {
    fbb_.AddOffset(Action::VT_CONFIG, config);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(Action::VT_COMMAND, command);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args) {
    fbb_.AddOffset(Action::VT_ARGS, args);
  }
  void add_activateTime(float activateTime) {
    fbb_.AddElement<float>(Action::VT_ACTIVATETIME, activateTime, 0.0f);
  }
  void add_currentTime(float currentTime) {
    fbb_.AddElement<float>(Action::VT_CURRENTTIME, currentTime, 0.0f);
  }
  void add_remotePath(flatbuffers::Offset<flatbuffers::String> remotePath) {
    fbb_.AddOffset(Action::VT_REMOTEPATH, remotePath);
  }
  void add_file(flatbuffers::Offset<flatbuffers::Vector<int8_t>> file) {
    fbb_.AddOffset(Action::VT_FILE, file);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionBuilder &operator=(const ActionBuilder &);
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> actionId = 0,
    ActionType actionType = ActionType_Config,
    flatbuffers::Offset<Config> config = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args = 0,
    float activateTime = 0.0f,
    float currentTime = 0.0f,
    flatbuffers::Offset<flatbuffers::String> remotePath = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> file = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_file(file);
  builder_.add_remotePath(remotePath);
  builder_.add_currentTime(currentTime);
  builder_.add_activateTime(activateTime);
  builder_.add_args(args);
  builder_.add_command(command);
  builder_.add_config(config);
  builder_.add_actionId(actionId);
  builder_.add_actionType(actionType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Action> CreateActionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *actionId = nullptr,
    ActionType actionType = ActionType_Config,
    flatbuffers::Offset<Config> config = 0,
    const char *command = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *args = nullptr,
    float activateTime = 0.0f,
    float currentTime = 0.0f,
    const char *remotePath = nullptr,
    const std::vector<int8_t> *file = nullptr) {
  auto actionId__ = actionId ? _fbb.CreateString(actionId) : 0;
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto args__ = args ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*args) : 0;
  auto remotePath__ = remotePath ? _fbb.CreateString(remotePath) : 0;
  auto file__ = file ? _fbb.CreateVector<int8_t>(*file) : 0;
  return anomaly::CreateAction(
      _fbb,
      actionId__,
      actionType,
      config,
      command__,
      args__,
      activateTime,
      currentTime,
      remotePath__,
      file__);
}

flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionResponseT : public flatbuffers::NativeTable {
  typedef ActionResponse TableType;
  std::string actionId;
  std::unique_ptr<ConfigT> config;
  std::string startTime;
  std::string endTime;
  bool error;
  std::string stdoutput;
  std::string stderror;
  ActionResponseT()
      : error(false) {
  }
};

inline bool operator==(const ActionResponseT &lhs, const ActionResponseT &rhs) {
  return
      (lhs.actionId == rhs.actionId) &&
      (lhs.config == rhs.config) &&
      (lhs.startTime == rhs.startTime) &&
      (lhs.endTime == rhs.endTime) &&
      (lhs.error == rhs.error) &&
      (lhs.stdoutput == rhs.stdoutput) &&
      (lhs.stderror == rhs.stderror);
}

inline bool operator!=(const ActionResponseT &lhs, const ActionResponseT &rhs) {
    return !(lhs == rhs);
}


struct ActionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionResponseT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIONID = 4,
    VT_CONFIG = 6,
    VT_STARTTIME = 8,
    VT_ENDTIME = 10,
    VT_ERROR = 12,
    VT_STDOUTPUT = 14,
    VT_STDERROR = 16
  };
  const flatbuffers::String *actionId() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTIONID);
  }
  flatbuffers::String *mutable_actionId() {
    return GetPointer<flatbuffers::String *>(VT_ACTIONID);
  }
  const Config *config() const {
    return GetPointer<const Config *>(VT_CONFIG);
  }
  Config *mutable_config() {
    return GetPointer<Config *>(VT_CONFIG);
  }
  const flatbuffers::String *startTime() const {
    return GetPointer<const flatbuffers::String *>(VT_STARTTIME);
  }
  flatbuffers::String *mutable_startTime() {
    return GetPointer<flatbuffers::String *>(VT_STARTTIME);
  }
  const flatbuffers::String *endTime() const {
    return GetPointer<const flatbuffers::String *>(VT_ENDTIME);
  }
  flatbuffers::String *mutable_endTime() {
    return GetPointer<flatbuffers::String *>(VT_ENDTIME);
  }
  bool error() const {
    return GetField<uint8_t>(VT_ERROR, 0) != 0;
  }
  bool mutate_error(bool _error) {
    return SetField<uint8_t>(VT_ERROR, static_cast<uint8_t>(_error), 0);
  }
  const flatbuffers::String *stdoutput() const {
    return GetPointer<const flatbuffers::String *>(VT_STDOUTPUT);
  }
  flatbuffers::String *mutable_stdoutput() {
    return GetPointer<flatbuffers::String *>(VT_STDOUTPUT);
  }
  const flatbuffers::String *stderror() const {
    return GetPointer<const flatbuffers::String *>(VT_STDERROR);
  }
  flatbuffers::String *mutable_stderror() {
    return GetPointer<flatbuffers::String *>(VT_STDERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIONID) &&
           verifier.VerifyString(actionId()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           VerifyOffset(verifier, VT_STARTTIME) &&
           verifier.VerifyString(startTime()) &&
           VerifyOffset(verifier, VT_ENDTIME) &&
           verifier.VerifyString(endTime()) &&
           VerifyField<uint8_t>(verifier, VT_ERROR) &&
           VerifyOffset(verifier, VT_STDOUTPUT) &&
           verifier.VerifyString(stdoutput()) &&
           VerifyOffset(verifier, VT_STDERROR) &&
           verifier.VerifyString(stderror()) &&
           verifier.EndTable();
  }
  ActionResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actionId(flatbuffers::Offset<flatbuffers::String> actionId) {
    fbb_.AddOffset(ActionResponse::VT_ACTIONID, actionId);
  }
  void add_config(flatbuffers::Offset<Config> config) {
    fbb_.AddOffset(ActionResponse::VT_CONFIG, config);
  }
  void add_startTime(flatbuffers::Offset<flatbuffers::String> startTime) {
    fbb_.AddOffset(ActionResponse::VT_STARTTIME, startTime);
  }
  void add_endTime(flatbuffers::Offset<flatbuffers::String> endTime) {
    fbb_.AddOffset(ActionResponse::VT_ENDTIME, endTime);
  }
  void add_error(bool error) {
    fbb_.AddElement<uint8_t>(ActionResponse::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  void add_stdoutput(flatbuffers::Offset<flatbuffers::String> stdoutput) {
    fbb_.AddOffset(ActionResponse::VT_STDOUTPUT, stdoutput);
  }
  void add_stderror(flatbuffers::Offset<flatbuffers::String> stderror) {
    fbb_.AddOffset(ActionResponse::VT_STDERROR, stderror);
  }
  explicit ActionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionResponseBuilder &operator=(const ActionResponseBuilder &);
  flatbuffers::Offset<ActionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionResponse> CreateActionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> actionId = 0,
    flatbuffers::Offset<Config> config = 0,
    flatbuffers::Offset<flatbuffers::String> startTime = 0,
    flatbuffers::Offset<flatbuffers::String> endTime = 0,
    bool error = false,
    flatbuffers::Offset<flatbuffers::String> stdoutput = 0,
    flatbuffers::Offset<flatbuffers::String> stderror = 0) {
  ActionResponseBuilder builder_(_fbb);
  builder_.add_stderror(stderror);
  builder_.add_stdoutput(stdoutput);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_config(config);
  builder_.add_actionId(actionId);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionResponse> CreateActionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *actionId = nullptr,
    flatbuffers::Offset<Config> config = 0,
    const char *startTime = nullptr,
    const char *endTime = nullptr,
    bool error = false,
    const char *stdoutput = nullptr,
    const char *stderror = nullptr) {
  auto actionId__ = actionId ? _fbb.CreateString(actionId) : 0;
  auto startTime__ = startTime ? _fbb.CreateString(startTime) : 0;
  auto endTime__ = endTime ? _fbb.CreateString(endTime) : 0;
  auto stdoutput__ = stdoutput ? _fbb.CreateString(stdoutput) : 0;
  auto stderror__ = stderror ? _fbb.CreateString(stderror) : 0;
  return anomaly::CreateActionResponse(
      _fbb,
      actionId__,
      config,
      startTime__,
      endTime__,
      error,
      stdoutput__,
      stderror__);
}

flatbuffers::Offset<ActionResponse> CreateActionResponse(flatbuffers::FlatBufferBuilder &_fbb, const ActionResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct APIT : public flatbuffers::NativeTable {
  typedef API TableType;
  std::string sessionId;
  std::string uuid;
  std::string hostname;
  std::vector<std::unique_ptr<NetInterfaceT>> interfaces;
  std::unique_ptr<ConfigT> config;
  std::vector<std::unique_ptr<ActionT>> actions;
  std::vector<std::unique_ptr<ActionResponseT>> responses;
  APIT() {
  }
};

inline bool operator==(const APIT &lhs, const APIT &rhs) {
  return
      (lhs.sessionId == rhs.sessionId) &&
      (lhs.uuid == rhs.uuid) &&
      (lhs.hostname == rhs.hostname) &&
      (lhs.interfaces == rhs.interfaces) &&
      (lhs.config == rhs.config) &&
      (lhs.actions == rhs.actions) &&
      (lhs.responses == rhs.responses);
}

inline bool operator!=(const APIT &lhs, const APIT &rhs) {
    return !(lhs == rhs);
}


struct API FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef APIT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_UUID = 6,
    VT_HOSTNAME = 8,
    VT_INTERFACES = 10,
    VT_CONFIG = 12,
    VT_ACTIONS = 14,
    VT_RESPONSES = 16
  };
  const flatbuffers::String *sessionId() const {
    return GetPointer<const flatbuffers::String *>(VT_SESSIONID);
  }
  flatbuffers::String *mutable_sessionId() {
    return GetPointer<flatbuffers::String *>(VT_SESSIONID);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  flatbuffers::String *mutable_uuid() {
    return GetPointer<flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *hostname() const {
    return GetPointer<const flatbuffers::String *>(VT_HOSTNAME);
  }
  flatbuffers::String *mutable_hostname() {
    return GetPointer<flatbuffers::String *>(VT_HOSTNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NetInterface>> *interfaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NetInterface>> *>(VT_INTERFACES);
  }
  flatbuffers::Vector<flatbuffers::Offset<NetInterface>> *mutable_interfaces() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<NetInterface>> *>(VT_INTERFACES);
  }
  const Config *config() const {
    return GetPointer<const Config *>(VT_CONFIG);
  }
  Config *mutable_config() {
    return GetPointer<Config *>(VT_CONFIG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Action>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Action>> *>(VT_ACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Action>> *mutable_actions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Action>> *>(VT_ACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ActionResponse>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ActionResponse>> *>(VT_RESPONSES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ActionResponse>> *mutable_responses() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ActionResponse>> *>(VT_RESPONSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSIONID) &&
           verifier.VerifyString(sessionId()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyVector(interfaces()) &&
           verifier.VerifyVectorOfTables(interfaces()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.VerifyVector(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           verifier.EndTable();
  }
  APIT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(APIT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<API> Pack(flatbuffers::FlatBufferBuilder &_fbb, const APIT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct APIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sessionId(flatbuffers::Offset<flatbuffers::String> sessionId) {
    fbb_.AddOffset(API::VT_SESSIONID, sessionId);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(API::VT_UUID, uuid);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(API::VT_HOSTNAME, hostname);
  }
  void add_interfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NetInterface>>> interfaces) {
    fbb_.AddOffset(API::VT_INTERFACES, interfaces);
  }
  void add_config(flatbuffers::Offset<Config> config) {
    fbb_.AddOffset(API::VT_CONFIG, config);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actions) {
    fbb_.AddOffset(API::VT_ACTIONS, actions);
  }
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionResponse>>> responses) {
    fbb_.AddOffset(API::VT_RESPONSES, responses);
  }
  explicit APIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  APIBuilder &operator=(const APIBuilder &);
  flatbuffers::Offset<API> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<API>(end);
    return o;
  }
};

inline flatbuffers::Offset<API> CreateAPI(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sessionId = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NetInterface>>> interfaces = 0,
    flatbuffers::Offset<Config> config = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionResponse>>> responses = 0) {
  APIBuilder builder_(_fbb);
  builder_.add_responses(responses);
  builder_.add_actions(actions);
  builder_.add_config(config);
  builder_.add_interfaces(interfaces);
  builder_.add_hostname(hostname);
  builder_.add_uuid(uuid);
  builder_.add_sessionId(sessionId);
  return builder_.Finish();
}

inline flatbuffers::Offset<API> CreateAPIDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sessionId = nullptr,
    const char *uuid = nullptr,
    const char *hostname = nullptr,
    const std::vector<flatbuffers::Offset<NetInterface>> *interfaces = nullptr,
    flatbuffers::Offset<Config> config = 0,
    const std::vector<flatbuffers::Offset<Action>> *actions = nullptr,
    const std::vector<flatbuffers::Offset<ActionResponse>> *responses = nullptr) {
  auto sessionId__ = sessionId ? _fbb.CreateString(sessionId) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto interfaces__ = interfaces ? _fbb.CreateVector<flatbuffers::Offset<NetInterface>>(*interfaces) : 0;
  auto actions__ = actions ? _fbb.CreateVector<flatbuffers::Offset<Action>>(*actions) : 0;
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<ActionResponse>>(*responses) : 0;
  return anomaly::CreateAPI(
      _fbb,
      sessionId__,
      uuid__,
      hostname__,
      interfaces__,
      config,
      actions__,
      responses__);
}

flatbuffers::Offset<API> CreateAPI(flatbuffers::FlatBufferBuilder &_fbb, const APIT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NetInterfaceT *NetInterface::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NetInterfaceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NetInterface::UnPackTo(NetInterfaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = macAddr(); if (_e) _o->macAddr = _e->str(); };
  { auto _e = ipAddrs(); if (_e) { _o->ipAddrs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ipAddrs[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<NetInterface> NetInterface::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetInterfaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNetInterface(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NetInterface> CreateNetInterface(flatbuffers::FlatBufferBuilder &_fbb, const NetInterfaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NetInterfaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _macAddr = _o->macAddr.empty() ? 0 : _fbb.CreateString(_o->macAddr);
  auto _ipAddrs = _o->ipAddrs.size() ? _fbb.CreateVectorOfStrings(_o->ipAddrs) : 0;
  return anomaly::CreateNetInterface(
      _fbb,
      _name,
      _macAddr,
      _ipAddrs);
}

inline ConfigT *Config::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConfigT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Config::UnPackTo(ConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = interval(); _o->interval = _e; };
  { auto _e = intervalDelta(); _o->intervalDelta = _e; };
  { auto _e = agentVersion(); if (_e) _o->agentVersion = _e->str(); };
  { auto _e = servers(); if (_e) { _o->servers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->servers[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Config> Config::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Config> CreateConfig(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _interval = _o->interval;
  auto _intervalDelta = _o->intervalDelta;
  auto _agentVersion = _o->agentVersion.empty() ? 0 : _fbb.CreateString(_o->agentVersion);
  auto _servers = _o->servers.size() ? _fbb.CreateVectorOfStrings(_o->servers) : 0;
  return anomaly::CreateConfig(
      _fbb,
      _interval,
      _intervalDelta,
      _agentVersion,
      _servers);
}

inline ActionT *Action::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Action::UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actionId(); if (_e) _o->actionId = _e->str(); };
  { auto _e = actionType(); _o->actionType = _e; };
  { auto _e = config(); if (_e) _o->config = std::unique_ptr<ConfigT>(_e->UnPack(_resolver)); };
  { auto _e = command(); if (_e) _o->command = _e->str(); };
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = _e->Get(_i)->str(); } } };
  { auto _e = activateTime(); _o->activateTime = _e; };
  { auto _e = currentTime(); _o->currentTime = _e; };
  { auto _e = remotePath(); if (_e) _o->remotePath = _e->str(); };
  { auto _e = file(); if (_e) { _o->file.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->file[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Action> Action::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actionId = _o->actionId.empty() ? 0 : _fbb.CreateString(_o->actionId);
  auto _actionType = _o->actionType;
  auto _config = _o->config ? CreateConfig(_fbb, _o->config.get(), _rehasher) : 0;
  auto _command = _o->command.empty() ? 0 : _fbb.CreateString(_o->command);
  auto _args = _o->args.size() ? _fbb.CreateVectorOfStrings(_o->args) : 0;
  auto _activateTime = _o->activateTime;
  auto _currentTime = _o->currentTime;
  auto _remotePath = _o->remotePath.empty() ? 0 : _fbb.CreateString(_o->remotePath);
  auto _file = _o->file.size() ? _fbb.CreateVector(_o->file) : 0;
  return anomaly::CreateAction(
      _fbb,
      _actionId,
      _actionType,
      _config,
      _command,
      _args,
      _activateTime,
      _currentTime,
      _remotePath,
      _file);
}

inline ActionResponseT *ActionResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ActionResponse::UnPackTo(ActionResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actionId(); if (_e) _o->actionId = _e->str(); };
  { auto _e = config(); if (_e) _o->config = std::unique_ptr<ConfigT>(_e->UnPack(_resolver)); };
  { auto _e = startTime(); if (_e) _o->startTime = _e->str(); };
  { auto _e = endTime(); if (_e) _o->endTime = _e->str(); };
  { auto _e = error(); _o->error = _e; };
  { auto _e = stdoutput(); if (_e) _o->stdoutput = _e->str(); };
  { auto _e = stderror(); if (_e) _o->stderror = _e->str(); };
}

inline flatbuffers::Offset<ActionResponse> ActionResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionResponse> CreateActionResponse(flatbuffers::FlatBufferBuilder &_fbb, const ActionResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actionId = _o->actionId.empty() ? 0 : _fbb.CreateString(_o->actionId);
  auto _config = _o->config ? CreateConfig(_fbb, _o->config.get(), _rehasher) : 0;
  auto _startTime = _o->startTime.empty() ? 0 : _fbb.CreateString(_o->startTime);
  auto _endTime = _o->endTime.empty() ? 0 : _fbb.CreateString(_o->endTime);
  auto _error = _o->error;
  auto _stdoutput = _o->stdoutput.empty() ? 0 : _fbb.CreateString(_o->stdoutput);
  auto _stderror = _o->stderror.empty() ? 0 : _fbb.CreateString(_o->stderror);
  return anomaly::CreateActionResponse(
      _fbb,
      _actionId,
      _config,
      _startTime,
      _endTime,
      _error,
      _stdoutput,
      _stderror);
}

inline APIT *API::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new APIT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void API::UnPackTo(APIT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionId(); if (_e) _o->sessionId = _e->str(); };
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = hostname(); if (_e) _o->hostname = _e->str(); };
  { auto _e = interfaces(); if (_e) { _o->interfaces.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->interfaces[_i] = std::unique_ptr<NetInterfaceT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = config(); if (_e) _o->config = std::unique_ptr<ConfigT>(_e->UnPack(_resolver)); };
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<ActionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = responses(); if (_e) { _o->responses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->responses[_i] = std::unique_ptr<ActionResponseT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<API> API::Pack(flatbuffers::FlatBufferBuilder &_fbb, const APIT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAPI(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<API> CreateAPI(flatbuffers::FlatBufferBuilder &_fbb, const APIT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const APIT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionId = _o->sessionId.empty() ? 0 : _fbb.CreateString(_o->sessionId);
  auto _uuid = _o->uuid.empty() ? 0 : _fbb.CreateString(_o->uuid);
  auto _hostname = _o->hostname.empty() ? 0 : _fbb.CreateString(_o->hostname);
  auto _interfaces = _o->interfaces.size() ? _fbb.CreateVector<flatbuffers::Offset<NetInterface>> (_o->interfaces.size(), [](size_t i, _VectorArgs *__va) { return CreateNetInterface(*__va->__fbb, __va->__o->interfaces[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _config = _o->config ? CreateConfig(_fbb, _o->config.get(), _rehasher) : 0;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<Action>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateAction(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _responses = _o->responses.size() ? _fbb.CreateVector<flatbuffers::Offset<ActionResponse>> (_o->responses.size(), [](size_t i, _VectorArgs *__va) { return CreateActionResponse(*__va->__fbb, __va->__o->responses[i].get(), __va->__rehasher); }, &_va ) : 0;
  return anomaly::CreateAPI(
      _fbb,
      _sessionId,
      _uuid,
      _hostname,
      _interfaces,
      _config,
      _actions,
      _responses);
}

inline const anomaly::API *GetAPI(const void *buf) {
  return flatbuffers::GetRoot<anomaly::API>(buf);
}

inline const anomaly::API *GetSizePrefixedAPI(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<anomaly::API>(buf);
}

inline API *GetMutableAPI(void *buf) {
  return flatbuffers::GetMutableRoot<API>(buf);
}

inline bool VerifyAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<anomaly::API>(nullptr);
}

inline bool VerifySizePrefixedAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<anomaly::API>(nullptr);
}

inline void FinishAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<anomaly::API> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<anomaly::API> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<APIT> UnPackAPI(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<APIT>(GetAPI(buf)->UnPack(res));
}

}  // namespace anomaly

#endif  // FLATBUFFERS_GENERATED_ANOMALYAPI_ANOMALY_H_
